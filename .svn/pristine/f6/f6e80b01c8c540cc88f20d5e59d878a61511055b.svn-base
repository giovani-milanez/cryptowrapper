/*
 * Asn1Wrapper.hpp
 *
 *  Criado em: 28/07/2014
 *      Autor: Giovani Milanez Espindola
 *  Copyright BRy Tecnologia 2014
 */

#ifndef ASN1WRAPPER_HPP_
#define ASN1WRAPPER_HPP_

namespace cryptoasn1wrapper {

class DerEncodable
{
public:
	virtual ~DerEncodable(){};
	virtual ByteArray getDerEncoded() const = 0;
};

class PemEncodable
{
public:
	virtual ~PemEncodable(){};
	virtual std::string getPemEncoded() const = 0;
};


template<typename T, T* (*D2I)(T**, const unsigned char **, long), int (*I2D)(T*, unsigned char **), void (*FreeFunc)(T*), T* (*DupFunc)(T*)>
class Asn1Object : public DerEncodable
{
public:
    static T *fromDer(const ByteArray& derEncoded)
    {
    	T *internal = nullptr;
		const unsigned char *tmp = derEncoded.begin();
        internal = D2I(nullptr, &tmp, derEncoded.size());
        if (internal == nullptr)
        {
        	throw cryptoasn1wrapper::DerDecodeException("");
        }
        return internal;
    }

	Asn1Object(T *p) :
        internal_(p)
	{
		if(p == nullptr)
			throw cryptoasn1wrapper::NullPointerException("");
	}
    virtual ~Asn1Object()
    {
    	FreeFunc(internal_);
    }

    Asn1Object(const Asn1Object& src) :
        internal_(DupFunc(src.internal_))
    {
    }
    Asn1Object& operator=(const Asn1Object& rhs)
    {
        T *tmp = DupFunc(rhs.internal_);
        FreeFunc(internal_);
        internal_ = tmp;
        return *this;
    }
    Asn1Object(Asn1Object&& src) :
        internal_(src.internal_)
    {
        src.internal_ = nullptr;
    }
    Asn1Object& operator=(Asn1Object&& rhs)
    {
        if (this == &rhs)
            return *this;
        FreeFunc(internal_);
        internal_ = rhs.internal_;
        rhs.internal_ = nullptr;
        return *this;
    }

	explicit Asn1Object(const ByteArray& derEncoded) :
		internal_(fromDer(derEncoded))
	{
	}

	operator T *() const
	{
		return internal_;
	}

    ByteArray getDerEncoded() const
	{
        std::size_t size = I2D(internal_, nullptr);
        cryptoasn1wrapper::ByteArray result(size);
        unsigned char *derPtr = result.begin();
        unsigned char *tmp = derPtr;
        I2D(internal_, &tmp);
        return result;
	}
    static T *fromDerFile(const std::string& filePath)
    {
    	return fromDer(createFromFile(filePath));
    }


	T *internal_;
protected:
};

template<typename T, T* (*D2I)(T**, const unsigned char **, long), int (*I2D)(T*, unsigned char **), void (*FreeFunc)(T*), T* (*DupFunc)(T*), int (*PemWrite)(BIO *, T *), T* (*PemRead)(BIO *, X509 **, pem_password_cb *, void *)>
class Asn1PemObject : public Asn1Object<T, D2I, I2D, FreeFunc, DupFunc>, public PemEncodable
{
public:
	using Asn1Object<T, D2I, I2D, FreeFunc, DupFunc>::Asn1Object; // inherit parent's constructor
	static T* fromPem(const std::string& pemEncoded)
	{
		T* internal = nullptr;

		BIO *buffer = BIO_new(BIO_s_mem());
		if ((unsigned int)(BIO_write(buffer, pemEncoded.c_str(), pemEncoded.size())) != pemEncoded.size())
		{
			BIO_free(buffer);
			throw cryptoasn1wrapper::BufferWriteException("Could not write PEM to buffer");
		}
		internal = PemRead(buffer, nullptr, nullptr, nullptr);
		if (internal == nullptr)
		{
			BIO_free(buffer);
			throw cryptoasn1wrapper::PemDecodeException("");
		}
		BIO_free(buffer);

		return internal;
	}
	static T* fromDerOrPem(const ByteArray& derOrPem)
	{
		try{
			return Asn1Object<T, D2I, I2D, FreeFunc, DupFunc>::fromDer(derOrPem);
		}catch(const cryptoasn1wrapper::DerDecodeException& ex){
			return fromPem(std::string((const char *)derOrPem.begin(), derOrPem.size()));
		}
	}
	static T* fromPemFile(const std::string& filePath)
	{
		ByteArray derEncoded = createFromFile(filePath);
		return fromPem(std::string((const char *)derEncoded.begin(), derEncoded.size()));
	}
	explicit Asn1PemObject(const std::string& pemEncoded) :
		Asn1Object<T, D2I, I2D, FreeFunc, DupFunc>(fromPem(pemEncoded))
    {
    }

	std::string getPemEncoded() const
	{
		const char *data;
		BIO *buffer = BIO_new(BIO_s_mem());
		PemWrite(buffer, this->internal_);
		std::size_t ndata = BIO_get_mem_data(buffer, &data);
		std::string ret(data, ndata);
		BIO_free(buffer);
		return ret;
	}
    static T *fromDerOrPemFile(const std::string& filePath)
    {
    	try{
    		return Asn1Object<T, D2I, I2D, FreeFunc, DupFunc>::fromDerFile(filePath);
    	}catch(const cryptoasn1wrapper::DerDecodeException& ex){
    		// der decode failed, lets try pem
    		return fromPemFile(filePath);
    	}
    }
};

#define EXPAND_ASN1(struct_name) Asn1Object<struct_name, d2i_##struct_name, i2d_##struct_name, struct_name##_free, struct_name##_dup>
#define EXPAND_ASN1_PEM(struct_name) Asn1PemObject<struct_name, d2i_##struct_name, i2d_##struct_name, struct_name##_free, struct_name##_dup, PEM_write_bio_##struct_name, PEM_read_bio_##struct_name>

}



#endif /* ASN1WRAPPER_HPP_ */
